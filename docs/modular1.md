On the Way to a Modular Cryptocurrency, Part 1: Generic Block Structure
========================================================================

The Protocols Mess Problem
--------------------------

In a code of a cryptocurrency of today logical parts are couply tied together making code unreadable &
  changes hard. This series of articles enlights how the problem could be solved by introducing 
  separate inter-changeable injectable modules.
  
This article, the first in the series describes how block structure & block-related functionality 
could be defined agnostic to implementation details of two separate modules, consensus & transaction.
   
Strictly-typed and modular Scala language is used to illustrate the approach.    


Generic Block Structure
-------------------------------------

Block consists of: 

1. Pointer to previous block
2. Consensus-related data, e.g.  nonce & difficulty target for Bitcoin, generation signature & base targer for Nxt.
3. Transactions, the most valuable part of a block for users. Some transactions- or state-related data could
be also included(e.g. Merkle tree root hash for transactions or whole state after block applying)
4. Additional utilitary information: block structure version, timestamp etc 
5. Signature(s)

(Please note [in Bitcoin there's no a signature of a block](https://en.bitcoin.it/wiki/Protocol_documentation#block), 
while we're going to add it) 

Making a new cryptocurrency usually means to replace (2) or (3) or both with something new. So to have an ability to 
make experiments fast we need to introduce flexible & modular approach to a block structure & corresponding block 
processing functions.
    
In the first place, we are going to introduce generic *block field* concept wrapping any kind of data with a possibility 
of serialization into json & binary form:
        
    abstract class BlockField[T] {
      val name: String
      val value: T

      def json: JsObject
      def bytes: Array[Byte]
    }        

Then we can stack up blockfields into block, introducing abstract ConsensusDataType & TransactionDataType types as
well as abstract references to ConsensusModule & TransactionModule *modules*, where a *module* is a functional 
interface to be replaced with a concrete implementation then:
    
    trait Block {
      type ConsensusDataType
      type TransactionDataType
      
      implicit val consensusModule: ConsensusModule[ConsensusDataType]
      implicit val transactionModule: TransactionModule[TransactionDataType]
            
      val consensusDataField: BlockField[ConsensusDataType]
      val transactionDataField: BlockField[TransactionDataType]                 
          
      val versionField: ByteBlockField
      val timestampField: LongBlockField
      val referenceField: BlockIdField
      val signerDataField: SignerDataBlockField    

      ...
      
What both modules could have in common? Well, they are parsing data of a type they're parametrized with, producing
 a blockfield based on data & provide genesis data details. Let's extract this functionality into root trait:
           
    trait BlockProcessingModule[BlockPartDataType] {
       def parseBlockData(bytes: Array[Byte]): BlockField[BlockPartDataType]

       def parseBlockFields(blockFields: BlockField[BlockPartDataType]): BlockPartDataType = blockFields.value

       def genesisData: BlockField[BlockPartDataType]

       def formBlockData(data: BlockPartDataType): BlockField[BlockPartDataType]
    }

Having this common ground, let's define consensus and transaction specific functions.           
      
Consensus Module
-----------------

   What can we do after reading consensus-related data from a block?
   
   * check whether a block is valid from module's point of view, i.e. whether a block was generated by a right 
   kind of participant in a right way
   * get block generator(s)(let's not forget about multiple generators possibility, see e.g.
                               Meni Rosenfeld's Proof-of-Activity proposal http://eprint.iacr.org/2014/452.pdf)
   * calculate reward(s) to block generator(s) 
   * get a score of a block. Score equals to 1 in case of longest chain rule or some calculated value relative to 
   difficulty in case of cumulative difficulty to be used to select best blockchain out of many possible options.  
                 
   Also, we can add a function to generate a block here, taking private key owner(to sign a block) and transaction module
    (to form transactional part of a block) as parameters.
    
   Considering all those functions, we can encode interface now:  

    trait ConsensusModule[ConsensusBlockData] extends BlockProcessingModule[ConsensusBlockData]{
      def isValid[TT](block: Block, history: History, state: State)(implicit transactionModule: TransactionModule[TT]): Boolean
  
      def feesDistribution(block: Block): Map[Account, Long]
  
      def generators(block: Block): Seq[Account]

      def blockScore(block: Block, history: History)(implicit transactionModule: TransactionModule[_]): BigInt

      def generateNextBlock[TT](account: PrivateKeyAccount)(implicit transactionModule: TransactionModule[TT]): Future[Option[Block]]
    }

Transaction Module
------------------
    
   Now let's define functional building blocks for a transactional part of a cryptocurrency.
    
      


The Concrete Implementation - Scores Lagonaki
---------------------------------------------


Further Work 
------------


Conclusion
----------
